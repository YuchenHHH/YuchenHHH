---
title: C语言内存分区
date: 2021-11-26 17:15:20
tags:
---

## 运行之前
再执行C程序之前, 第一步需要对程序进行编译

1. 预处理: 宏定义展开, 头文件展开, 条件编译, 这里并不会检查语法;
2. 编译: 检查语法, 将预处理后文件编译生成汇编文件;
3. 汇编: 将汇编文件生成目标文件(二进制文件);
4. 链接: 将目标文件链接成可执行程序.

下面是一个最基本的C程序
```C
// filename: test.c
#include <stdio.h>

int main()
{
    printf("hello, world\n");
    return 0;
}
```
在编译完生成可执行文件之后, 通过linux下的 size 命令可以查看一个可执行二进制文件的基本情况
```bash
gcc test.c -o test
size test
```

```
   text    data     bss     dec     hex filename
   1566     600       8    2174     87e test
```
- text: 代码区
- data: 静态数据/全局初始化数据区
- bss: 未初始化数据区
- dec: 十进制总和
- hex: 十六进制总和

由上可知, 在程序没有加载到内存前, 可执行内部已经分好了3段信息, 分为代码区, 数据区和未初始化数据区.

### 代码区(text)
存放 CPU执行的机器指令, 通常代码区是**共享**的(即另外的执行的程序可以调用它), 十七可共享的目的是对于平凡执行的程序, 只需要在内存中有一份代码即可.

代码区通常是**只读**的, 其目的是防止程序意外修改其指令.

### 静态数据/全局初始化数据区(data)
包含被初始化的全局变量, 已经初始化的静态变量和常量

### 未初始化数据区(bss)
未初始化数据区在程序开始执行之前呗内核初始化为 0 或 NULL.

## 运行之后

### 栈区(stack)
由编译器自动分配释放, 存放函数的参数值, 返回值以及局部变量等, 在运行过程中实时加载和释放, 因此生命周期为申请到释放该段栈空间.

### 堆区(heap)
堆是一个大容器, 容量要远远大于栈. 一般由程序员分配和释放, 若不释放, 程序结束时由操作系统释放.

### 数据区
静态变量在程序运行前分配内存,生命周期在程序运行结束时死亡;

默认属于内部链接属性, 只能在当前文件中使用.
```C
// filename: test.c
static int a = 10;

// filaname: test1.c
a = 100; // 错误, 在文件外无法访问
```

全局变量关键字extern, 属于外部链接属性
```C
// filename: test.c
int a = 10; // 默认是外部链接属性

// filaname: test1.c
extern int a; // 链接时在其他文件中查找, 如果没有, 报错
a = 100 
```
编译命令为
```bash
gcc test1.c test.c -o main
```

const常量
```C
const int a = 10; // 全局const

void test()
{
    a = 100; // 直接修改失败
    int *p = &a;
    *p = 10; // 间接修改失败
}

void test2()
{
    const int b = 100; // 数据存放在栈区, 并不是常量
    b = 10; // 直接修改失败
    int *p = &b;
    *p = 10; // 可以修改, 但是会报警告

}
```

字符串常量
```C
void test()
{
    char *p1 = "hello";
    char *p2 = "hello";
    char *p3 = "hello";

    printf("%d\n", (int)p1);
    printf("%d\n", (int)p2);
    printf("%d\n", (int)p3);
    printf("%d\n", (int)"hello");
}
```
得到结果为
```
1721774088
1721774088
1721774088
1721774088
```
因此字符串常量是可以共享的, 置于常量区. 
ANSI C 规定: 字符串常量的修改是未定义的行为

## 函数调用流程
宏函数注意, 保证运算的完整性. 将频繁, 短小的函数封装为宏函数(以空间换时间).

主调函数和被调函数要有一致约定, 才能正确调用函数, 这个约定称为调用惯例

C/C++ 默认调用惯例为 cdecl

调用惯例: cdecl(默认)

出栈方: 函数调用方(主调函数)

参数传递: 从右往左参数入栈

名字修饰: 下划线+函数名

栈的生长方向: 栈底高地址, 栈顶低地址
